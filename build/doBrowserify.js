"use strict";

var path = require("path");
var browserify = require("browserify");
var browserifyHandlers = require("./browserifyHandlers");
var urlize = require("./utils").urlize;

// This module does something a bit unorthodox: it uses Browserify to output a single file for each module, instead of
// squashing them all into one in the usual way. The result is a prelude file and a bunch of bundle files. Doing so
// means twisting Browserify in strange and unusual ways, so things can get a bit hard to follow. We try to comment.

function isBuiltin(filePath) {
    // This is a heuristic method of determining whether a module is a Browserify built-in. We handle built-ins
    // differently from normal modules, since they must be bundled in the prelude file.
    var pieces = filePath.split(path.sep);
    var browserifyIndex = pieces.indexOf("browserify");
    var builtinsIndex = pieces.indexOf("builtins");

    return browserifyIndex !== -1 && builtinsIndex !== -1 && builtinsIndex === browserifyIndex + 1;
}

function createWrappedFilesMap(bundle) {
    // The `bundle.files` property maps absolute file paths to unwrapped module bodies. Use it to create a map of
    // relative file paths to wrapped module bodies.
    var files = Object.create(null);
    Object.keys(bundle.files).forEach(function (filePath) {
        if (!isBuiltin(filePath)) {
            var relativeFilePath = path.relative(process.cwd(), filePath);
            files[filePath] = bundle.wrap(urlize(relativeFilePath), bundle.files[filePath].body);
        }
    });
    return files;
}

function makePreludeFile() {
    // Create a bundle. It currently contains the prelude and some builtins.
    var bundle = browserify({ cache: true });

    // This will return a string containing the contents of the prelude file, i.e. all the Browserify definitions
    // (`require`, `require.define`, etc.).
    return bundle.bundle();
}

function makeAliasesFile(aliases) {
    // Create a bundle with the aliases. It currently contains the prelude, the aliases, and some builtins.
    var bundle = browserify({ require: aliases, cache: true });

    // Remove all actual files and the prelude: we just want the `require.alias` calls.
    bundle.files = {};
    bundle.prepends = [];

    // This will return a string containing the the `require.alias` calls generated by passing in the aliases above.
    return bundle.bundle();
}

function makeWrappedAliasedModules(aliases) {
    // Create a bundle with the aliases in it, but remove the builtins.
    var bundle = browserify({ require: aliases, cache: true });

    // Turn it into a relative file path → wrapped module bodies map.
    return createWrappedFilesMap(bundle);
}

function makeWrappedModules(aliases, entryFile) {
    var bundle = browserify({ cache: true });

    // We manually call `bundle.alias` here so that the files we include know about the aliases during build time, even
    // though the actual aliased file contents will be output separately, and the `require.alias` calls will end up in
    // their own aliases file.
    Object.keys(aliases).forEach(function (alias) {
        bundle.alias(alias, aliases[alias]);
    });

    // Registering browserify handlers will allow the browserified .js modules to require other things, e.g. Jade.
    Object.keys(browserifyHandlers).forEach(function (extension) {
        bundle.register(extension, browserifyHandlers[extension].handler);
    });

    // Just require the entry file: this will create entries in the `bundle.files` map for all files it requires,
    // recursively.
    bundle.require(path.resolve(entryFile));

    // Turn it into a relative file path → wrapped module bodies map.
    return createWrappedFilesMap(bundle);
}

module.exports = function (grunt, config) {
    // This is the array of URLs for the files we write out, to be returned to the caller.
    var newFileUrls = [];

    function asInDest(filePath) {
        // Takes an absolute path and makes it a relative path, but inside config.dest.
        var relativePath = path.relative(process.cwd(), filePath);
        return path.relative(process.cwd(), path.resolve(config.dest, relativePath));
    }

    function writeFile(description, filePath, contents) {
        var destFilePath = asInDest(filePath);
        var destFileUrl = urlize(destFilePath);

        grunt.file.write(destFilePath, contents);
        grunt.log.writeln("Browserify " + description + " created at \"" + destFilePath + "\"");

        newFileUrls.push(destFileUrl);
    }

    // Write the prelude file, containing all the Browserify `require` definitions.
    writeFile("prelude", "browserify.js", makePreludeFile());

    // Write the files for aliased modules.
    var aliasedModules = makeWrappedAliasedModules(config.aliases);
    Object.keys(aliasedModules).forEach(function (filePath) {
        writeFile("module", filePath, aliasedModules[filePath]);
    });

    // Write the aliases file, containing the `require.alias` declarations.
    writeFile("aliases file", "browserify-aliases.js", makeAliasesFile(config.aliases));

    // Each browserify handler can specify an array of scripts that should be included. Write these.
    Object.keys(browserifyHandlers).forEach(function (extension) {
        browserifyHandlers[extension].includeScripts.forEach(function (filePath) {
            writeFile("handler script", filePath, grunt.file.read(filePath));
        });
    });

    // Finally, wrap the entry module and all its dependencies, recursively; write those.
    var wrappedModules = makeWrappedModules(config.aliases, config.entry);
    Object.keys(wrappedModules).forEach(function (filePath) {
        writeFile("module", filePath, wrappedModules[filePath]);
    });

    return newFileUrls;
};
